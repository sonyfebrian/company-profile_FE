{"ast":null,"code":"\"use strict\";\n\nvar objectAssign = require('object-assign');\n/* eslint-disable max-depth, complexity */\n\n\nfunction nestLists(blocks) {\n  var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'html';\n  var tree = [];\n  var currentList;\n\n  for (var i = 0; i < blocks.length; i++) {\n    var block = blocks[i];\n\n    if (!isListBlock(block)) {\n      tree.push(block);\n      currentList = null;\n      continue;\n    } // Start of a new list?\n\n\n    if (!currentList) {\n      currentList = listFromBlock(block);\n      tree.push(currentList);\n      continue;\n    } // New list item within same list?\n\n\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block);\n      continue;\n    } // Different list props, are we going deeper?\n\n\n    if (block.level > currentList.level) {\n      var newList = listFromBlock(block);\n\n      if (mode === 'html') {\n        // Because HTML is kinda weird, nested lists needs to be nested within list items\n        // So while you would think that we could populate the parent list with a new sub-list,\n        // We actually have to target the last list element (child) of the parent.\n        // However, at this point we need to be very careful - simply pushing to the list of children\n        // will mutate the input, and we don't want to blindly clone the entire tree.\n        // Clone the last child while adding our new list as the last child of it\n        var lastListItem = lastChild(currentList);\n        var newLastChild = objectAssign({}, lastListItem, {\n          children: lastListItem.children.concat(newList)\n        }); // Swap the last child\n\n        currentList.children[currentList.children.length - 1] = newLastChild;\n      } else {\n        currentList.children.push(newList);\n      } // Set the newly created, deeper list as the current\n\n\n      currentList = newList;\n      continue;\n    } // Different list props, are we going back up the tree?\n\n\n    if (block.level < currentList.level) {\n      // Current list has ended, and we need to hook up with a parent of the same level and type\n      var match = findListMatching(tree[tree.length - 1], block);\n\n      if (match) {\n        currentList = match;\n        currentList.children.push(block);\n        continue;\n      } // Similar parent can't be found, assume new list\n\n\n      currentList = listFromBlock(block);\n      tree.push(currentList);\n      continue;\n    } // Different list props, different list style?\n\n\n    if (block.listItem !== currentList.listItem) {\n      var _match = findListMatching(tree[tree.length - 1], {\n        level: block.level\n      });\n\n      if (_match && _match.listItem === block.listItem) {\n        currentList = _match;\n        currentList.children.push(block);\n        continue;\n      } else {\n        currentList = listFromBlock(block);\n        tree.push(currentList);\n        continue;\n      }\n    } // eslint-disable-next-line no-console\n\n\n    console.warn('Unknown state encountered for block', block);\n    tree.push(block);\n  }\n\n  return tree;\n}\n\nfunction isListBlock(block) {\n  return Boolean(block.listItem);\n}\n\nfunction blockMatchesList(block, list) {\n  return block.level === list.level && block.listItem === list.listItem;\n}\n\nfunction listFromBlock(block) {\n  return {\n    _type: 'list',\n    _key: \"\".concat(block._key, \"-parent\"),\n    level: block.level,\n    listItem: block.listItem,\n    children: [block]\n  };\n}\n\nfunction lastChild(block) {\n  return block.children && block.children[block.children.length - 1];\n}\n\nfunction findListMatching(rootNode, matching) {\n  var filterOnType = typeof matching.listItem === 'string';\n\n  if (rootNode._type === 'list' && rootNode.level === matching.level && filterOnType && rootNode.listItem === matching.listItem) {\n    return rootNode;\n  }\n\n  var node = lastChild(rootNode);\n\n  if (!node) {\n    return false;\n  }\n\n  return findListMatching(node, matching);\n}\n\nmodule.exports = nestLists;","map":{"version":3,"mappings":"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","names":["objectAssign","require","nestLists","blocks","mode","tree","currentList","i","length","block","isListBlock","push","listFromBlock","blockMatchesList","children","level","newList","lastListItem","lastChild","newLastChild","concat","match","findListMatching","listItem","console","warn","Boolean","list","_type","_key","rootNode","matching","filterOnType","node","module","exports"],"sources":["/home/sony/Data/FE/company-profile/node_modules/@sanity/block-content-to-hyperscript/src/nestLists.js"],"sourcesContent":["const objectAssign = require('object-assign')\n\n/* eslint-disable max-depth, complexity */\nfunction nestLists(blocks, mode = 'html') {\n  const tree = []\n  let currentList\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i]\n    if (!isListBlock(block)) {\n      tree.push(block)\n      currentList = null\n      continue\n    }\n\n    // Start of a new list?\n    if (!currentList) {\n      currentList = listFromBlock(block)\n      tree.push(currentList)\n      continue\n    }\n\n    // New list item within same list?\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block)\n      continue\n    }\n\n    // Different list props, are we going deeper?\n    if (block.level > currentList.level) {\n      const newList = listFromBlock(block)\n\n      if (mode === 'html') {\n        // Because HTML is kinda weird, nested lists needs to be nested within list items\n        // So while you would think that we could populate the parent list with a new sub-list,\n        // We actually have to target the last list element (child) of the parent.\n        // However, at this point we need to be very careful - simply pushing to the list of children\n        // will mutate the input, and we don't want to blindly clone the entire tree.\n\n        // Clone the last child while adding our new list as the last child of it\n        const lastListItem = lastChild(currentList)\n        const newLastChild = objectAssign({}, lastListItem, {\n          children: lastListItem.children.concat(newList)\n        })\n\n        // Swap the last child\n        currentList.children[currentList.children.length - 1] = newLastChild\n      } else {\n        currentList.children.push(newList)\n      }\n\n      // Set the newly created, deeper list as the current\n      currentList = newList\n      continue\n    }\n\n    // Different list props, are we going back up the tree?\n    if (block.level < currentList.level) {\n      // Current list has ended, and we need to hook up with a parent of the same level and type\n      const match = findListMatching(tree[tree.length - 1], block)\n      if (match) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      }\n\n      // Similar parent can't be found, assume new list\n      currentList = listFromBlock(block)\n      tree.push(currentList)\n      continue\n    }\n\n    // Different list props, different list style?\n    if (block.listItem !== currentList.listItem) {\n      const match = findListMatching(tree[tree.length - 1], {level: block.level})\n      if (match && match.listItem === block.listItem) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      } else {\n        currentList = listFromBlock(block)\n        tree.push(currentList)\n        continue\n      }\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn('Unknown state encountered for block', block)\n    tree.push(block)\n  }\n\n  return tree\n}\n\nfunction isListBlock(block) {\n  return Boolean(block.listItem)\n}\n\nfunction blockMatchesList(block, list) {\n  return block.level === list.level && block.listItem === list.listItem\n}\n\nfunction listFromBlock(block) {\n  return {\n    _type: 'list',\n    _key: `${block._key}-parent`,\n    level: block.level,\n    listItem: block.listItem,\n    children: [block]\n  }\n}\n\nfunction lastChild(block) {\n  return block.children && block.children[block.children.length - 1]\n}\n\nfunction findListMatching(rootNode, matching) {\n  const filterOnType = typeof matching.listItem === 'string'\n  if (\n    rootNode._type === 'list' &&\n    rootNode.level === matching.level &&\n    (filterOnType && rootNode.listItem === matching.listItem)\n  ) {\n    return rootNode\n  }\n\n  const node = lastChild(rootNode)\n  if (!node) {\n    return false\n  }\n\n  return findListMatching(node, matching)\n}\n\nmodule.exports = nestLists\n"]},"metadata":{},"sourceType":"script"}