{"ast":null,"code":"\"use strict\";\n\nvar defaultMarks = ['strong', 'em', 'code', 'underline', 'strike-through'];\n\nvar buildMarksTree = function buildMarksTree(block) {\n  var children = block.children,\n      markDefs = block.markDefs;\n\n  if (!children || !children.length) {\n    return [];\n  }\n\n  var sortedMarks = children.map(sortMarksByOccurences);\n  var rootNode = {\n    _type: 'span',\n    children: []\n  };\n  var nodeStack = [rootNode];\n  children.forEach(function (span, i) {\n    var marksNeeded = sortedMarks[i];\n\n    if (!marksNeeded) {\n      var lastNode = nodeStack[nodeStack.length - 1];\n      lastNode.children.push(span);\n      return;\n    }\n\n    var pos = 1; // Start at position one. Root is always plain and should never be removed. (?)\n\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        var mark = nodeStack[pos].markKey;\n        var index = marksNeeded.indexOf(mark); // eslint-disable-next-line max-depth\n\n        if (index === -1) {\n          break;\n        }\n\n        marksNeeded.splice(index, 1);\n      }\n    } // Keep from beginning to first miss\n\n\n    nodeStack = nodeStack.slice(0, pos); // Add needed nodes\n\n    var currentNode = findLastParentNode(nodeStack);\n    marksNeeded.forEach(function (mark) {\n      var node = {\n        _type: 'span',\n        _key: span._key,\n        children: [],\n        mark: markDefs.find(function (def) {\n          return def._key === mark;\n        }) || mark,\n        markKey: mark\n      };\n      currentNode.children.push(node);\n      nodeStack.push(node);\n      currentNode = node;\n    }); // Split at newlines to make individual line chunks, but keep newline\n    // characters as individual elements in the array. We use these characters\n    // in the span serializer to trigger hard-break rendering\n\n    if (isTextSpan(span)) {\n      var lines = span.text.split('\\n');\n\n      for (var line = lines.length; line-- > 1;) {\n        lines.splice(line, 0, '\\n');\n      }\n\n      currentNode.children = currentNode.children.concat(lines);\n    } else {\n      currentNode.children = currentNode.children.concat(span);\n    }\n  });\n  return rootNode.children;\n}; // We want to sort all the marks of all the spans in the following order:\n// 1. Marks that are shared amongst the most adjacent siblings\n// 2. Non-default marks (links, custom metadata)\n// 3. Built-in, plain marks (bold, emphasis, code etc)\n\n\nfunction sortMarksByOccurences(span, i, spans) {\n  if (!span.marks || span.marks.length === 0) {\n    return span.marks || [];\n  }\n\n  var markOccurences = span.marks.reduce(function (occurences, mark) {\n    occurences[mark] = occurences[mark] ? occurences[mark] + 1 : 1;\n\n    for (var siblingIndex = i + 1; siblingIndex < spans.length; siblingIndex++) {\n      var sibling = spans[siblingIndex];\n\n      if (sibling.marks && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) {\n        occurences[mark]++;\n      } else {\n        break;\n      }\n    }\n\n    return occurences;\n  }, {});\n  var sortByOccurence = sortMarks.bind(null, markOccurences); // Slicing because sort() mutates the input\n\n  return span.marks.slice().sort(sortByOccurence);\n}\n\nfunction sortMarks(occurences, markA, markB) {\n  var aOccurences = occurences[markA] || 0;\n  var bOccurences = occurences[markB] || 0;\n\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences;\n  }\n\n  var aDefaultPos = defaultMarks.indexOf(markA);\n  var bDefaultPos = defaultMarks.indexOf(markB); // Sort default marks last\n\n  if (aDefaultPos !== bDefaultPos) {\n    return aDefaultPos - bDefaultPos;\n  } // Sort other marks simply by key\n\n\n  if (markA < markB) {\n    return -1;\n  } else if (markA > markB) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction isTextSpan(node) {\n  return node._type === 'span' && typeof node.text === 'string' && (Array.isArray(node.marks) || typeof node.marks === 'undefined');\n}\n\nfunction findLastParentNode(nodes) {\n  for (var i = nodes.length - 1; i >= 0; i--) {\n    var node = nodes[i];\n\n    if (node._type === 'span' && node.children) {\n      return node;\n    }\n  }\n\n  return undefined;\n}\n\nmodule.exports = buildMarksTree;","map":{"version":3,"mappings":"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","names":["defaultMarks","buildMarksTree","children","block","markDefs","length","sortedMarks","map","sortMarksByOccurences","rootNode","_type","nodeStack","forEach","span","i","marksNeeded","lastNode","push","pos","mark","markKey","index","indexOf","splice","slice","currentNode","findLastParentNode","node","_key","find","def","isTextSpan","lines","text","split","line","concat","spans","marks","markOccurences","reduce","occurences","siblingIndex","sibling","Array","isArray","sortByOccurence","sortMarks","bind","sort","markA","markB","aOccurences","bOccurences","aDefaultPos","bDefaultPos","nodes","undefined","module","exports"],"sources":["/home/sony/Data/FE/company-profile/node_modules/@sanity/block-content-to-hyperscript/src/buildMarksTree.js"],"sourcesContent":["const defaultMarks = ['strong', 'em', 'code', 'underline', 'strike-through']\n\nconst buildMarksTree = block => {\n  const {children, markDefs} = block\n  if (!children || !children.length) {\n    return []\n  }\n\n  const sortedMarks = children.map(sortMarksByOccurences)\n  const rootNode = {_type: 'span', children: []}\n  let nodeStack = [rootNode]\n\n  children.forEach((span, i) => {\n    const marksNeeded = sortedMarks[i]\n    if (!marksNeeded) {\n      const lastNode = nodeStack[nodeStack.length - 1]\n      lastNode.children.push(span)\n      return\n    }\n\n    let pos = 1\n\n    // Start at position one. Root is always plain and should never be removed. (?)\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        const mark = nodeStack[pos].markKey\n        const index = marksNeeded.indexOf(mark)\n        // eslint-disable-next-line max-depth\n        if (index === -1) {\n          break\n        }\n\n        marksNeeded.splice(index, 1)\n      }\n    }\n\n    // Keep from beginning to first miss\n    nodeStack = nodeStack.slice(0, pos)\n\n    // Add needed nodes\n    let currentNode = findLastParentNode(nodeStack)\n    marksNeeded.forEach(mark => {\n      const node = {\n        _type: 'span',\n        _key: span._key,\n        children: [],\n        mark: markDefs.find(def => def._key === mark) || mark,\n        markKey: mark\n      }\n\n      currentNode.children.push(node)\n      nodeStack.push(node)\n      currentNode = node\n    })\n\n    // Split at newlines to make individual line chunks, but keep newline\n    // characters as individual elements in the array. We use these characters\n    // in the span serializer to trigger hard-break rendering\n    if (isTextSpan(span)) {\n      const lines = span.text.split('\\n')\n      for (let line = lines.length; line-- > 1; ) {\n        lines.splice(line, 0, '\\n')\n      }\n\n      currentNode.children = currentNode.children.concat(lines)\n    } else {\n      currentNode.children = currentNode.children.concat(span)\n    }\n  })\n\n  return rootNode.children\n}\n\n// We want to sort all the marks of all the spans in the following order:\n// 1. Marks that are shared amongst the most adjacent siblings\n// 2. Non-default marks (links, custom metadata)\n// 3. Built-in, plain marks (bold, emphasis, code etc)\nfunction sortMarksByOccurences(span, i, spans) {\n  if (!span.marks || span.marks.length === 0) {\n    return span.marks || []\n  }\n\n  const markOccurences = span.marks.reduce((occurences, mark) => {\n    occurences[mark] = occurences[mark] ? occurences[mark] + 1 : 1\n\n    for (let siblingIndex = i + 1; siblingIndex < spans.length; siblingIndex++) {\n      const sibling = spans[siblingIndex]\n\n      if (sibling.marks && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) {\n        occurences[mark]++\n      } else {\n        break\n      }\n    }\n\n    return occurences\n  }, {})\n\n  const sortByOccurence = sortMarks.bind(null, markOccurences)\n\n  // Slicing because sort() mutates the input\n  return span.marks.slice().sort(sortByOccurence)\n}\n\nfunction sortMarks(occurences, markA, markB) {\n  const aOccurences = occurences[markA] || 0\n  const bOccurences = occurences[markB] || 0\n\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences\n  }\n\n  const aDefaultPos = defaultMarks.indexOf(markA)\n  const bDefaultPos = defaultMarks.indexOf(markB)\n\n  // Sort default marks last\n  if (aDefaultPos !== bDefaultPos) {\n    return aDefaultPos - bDefaultPos\n  }\n\n  // Sort other marks simply by key\n  if (markA < markB) {\n    return -1\n  } else if (markA > markB) {\n    return 1\n  }\n\n  return 0\n}\n\nfunction isTextSpan(node) {\n  return (\n    node._type === 'span' &&\n    typeof node.text === 'string' &&\n    (Array.isArray(node.marks) || typeof node.marks === 'undefined')\n  )\n}\n\nfunction findLastParentNode(nodes) {\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    const node = nodes[i]\n    if (node._type === 'span' && node.children) {\n      return node\n    }\n  }\n\n  return undefined\n}\n\nmodule.exports = buildMarksTree\n"]},"metadata":{},"sourceType":"script"}